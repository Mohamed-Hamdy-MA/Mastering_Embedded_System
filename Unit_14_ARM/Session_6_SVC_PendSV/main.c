/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "STM32F103x6.h"
#include "STM32F103x6_GPIO_Driver.h"
#include "STM32F103x6_EXTI_Driver.h"

#include "core_cm3.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


#define Switch_To_UnPrivileged		__asm volatile (	"MRS r0, CONTROL	\n"		\
														"ORR r0, r0, #0x1	\n"		\
														"MSR CONTROL, r0		"	\
														:							\
														:							\
														: "r0", "cc"	)

#define Switch_To_Privileged		__asm volatile (	"MRS r0, CONTROL			\n"		\
														"AND r0, r0, #0xFFFFFFFE	\n"		\
														"MSR CONTROL, r0				"	\
														:									\
														:									\
														: "r0", "cc"	)

#define Switch_To_PSP				__asm volatile (	"MRS r0, CONTROL	\n"		\
														"ORR r0, r0, #0x2	\n"		\
														"MSR CONTROL, r0		"	\
														:							\
														:							\
														: "r0", "cc"	)

#define Switch_To_MSP				__asm volatile (	"MRS r0, CONTROL			\n"		\
														"AND r0, r0, #0xFFFFFFFD	\n"		\
														"MSR CONTROL, r0				"	\
														:									\
														:									\
														: "r0", "cc"	)

#define Set_PSP_Address(Address)	__asm volatile (	"MOV r0, %0			\n"		\
														"MSR PSP, r0			"	\
														:							\
														:"r" (Address)				\
														: "r0", "cc"	)

#define Set_MSP_Address(Address)	__asm volatile (	"MOV r0, %0			\n"		\
														"MSR MSP, r0			"	\
														:							\
														:"r" (Address)				\
														: "r0", "cc"	)

#define MSP_StackSize		512U		// 512 bytes = 0x200
#define TaskA_StackSize		100U		// 100 bytes = 0x64
#define TaskB_StackSize		100U		// 100 bytes = 0x64

extern uint32_t _estack;
uint32_t _sMSP = (uint32_t) &_estack;

uint8_t TaskAFlag = 0;
int32_t TaskA(int32_t a, int32_t b, int32_t c, int32_t d)
{
	return a+b+c+d;
}

uint8_t TaskBFlag = 0;
int32_t TaskB(int32_t a, int32_t b, int32_t c, int32_t d, int32_t e)
{
	return a+b+c+d+e;
}

uint8_t irqFlag = 1;
void myPB9EXTIHandler(void)
{
	if (irqFlag == 1)
	{
		irqFlag = 0;
		TaskAFlag = 1;
	}
	else
	{
		irqFlag = 1;
		TaskBFlag = 1;
	}
}

void PendSV_Handler(void)
{

}
void SVC_Handler_C(uint32_t* SVC_args)
{
	/*
	uint32_t Stacked_R0 	= SVC_args[0];
	uint32_t Stacked_R1 	= SVC_args[1];
	uint32_t Stacked_R2 	= SVC_args[2];
	uint32_t Stacked_R3 	= SVC_args[3];
	uint32_t Stacked_R12 	= SVC_args[4];
	uint32_t Stacked_LR 	= SVC_args[5];
	uint32_t Stacked_PC 	= SVC_args[6];
	uint32_t Stacked_xPSR 	= SVC_args[7];
	*/

	uint32_t SVC_Number 	= ( (uint8_t*) SVC_args[6] )[-2];

	switch (SVC_Number)
	{
	case 0x00:		//Switch To Privileged
		Switch_To_Privileged;
	case 0x01:		//Add Stacked_R0, Stacked_R1
		SVC_args[0] = SVC_args[0] + SVC_args[1];
		break;
	case 0x02:		//Sub Stacked_R0, Stacked_R1
		SVC_args[0] = SVC_args[0] - SVC_args[1];
		break;
	case 0x03:		//Mul Stacked_R0, Stacked_R1
		SVC_args[0] = SVC_args[0] * SVC_args[1];
		break;
	case 0x04:		//Enable PendSV
		SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
		break;
	default:
		break;
		}

	/* In the cases 0x01, 0x02, and 0x03, we assume that the arguments of the OS_SVC_Service function
	 * are still stored in the R0 and R1 registers at the time of the SVC exception.
	 * This assumption holds true in this example because the OS_SVC_Service function
	 * does not perform any operations that would overwrite R0 or R1 before triggering the SVC exception.
	 *
	 * However, in a real-world scenario, the OS_SVC_Service function is likely to include additional functionality,
	 * which may modify the R0 and R1 registers before the SVC exception is called.
	 * In such cases, the values of the arguments in R0 and R1 would need to be preserved
	 * (e.g., by saving them on the stack) to ensure they are available when the SVC handler executes.
	 */

}
__attribute ((naked)) void SVC_Handler(void)
{
	__asm volatile ("TST LR, 0b100		\n"
					"ITE EQ				\n"
					"MRSEQ r0, MSP		\n"
					"MRSNE r0, PSP		\n"
					"B SVC_Handler_C	"
					:
					:
					: "r0", "cc"	);
}
int32_t OS_SVC_Service(int32_t a, int32_t, uint8_t Service_ID)
{
	register uint32_t arg0 asm("r0");
	register uint32_t arg1 asm("r1");

	// Save R0 and R1 to local variables
	uint32_t saved_r0 = arg0;
	uint32_t saved_r1 = arg1;

	// Perform operations that might modify R0 and R1
	// ...

	// Restore R0 and R1 from local variables

	// Call SVC exception

	int32_t ReturnValue = 0;

	switch (Service_ID)
	{
	case 0x01:		//Add
		arg0 = saved_r0;
		arg1 = saved_r1;
		__asm volatile ("SVC #0x01");
		break;
	case 0x02:		//Sub
		arg0 = saved_r0;
		arg1 = saved_r1;
		__asm volatile ("SVC #0x02");
		break;
	case 0x03:		//Mul
		arg0 = saved_r0;
		arg1 = saved_r1;
		__asm volatile ("SVC #0x03");
		break;
	default:
		break;
	}

	__asm volatile ("MOV %0, R0"
					: "=r" (ReturnValue)
					:
					: "r0", "cc"	);
	return ReturnValue;
}


void mainOS(void)
{
	// MSP
	uint32_t _eMSP = (_sMSP - MSP_StackSize);

	// TaskA
	uint32_t _sTaskAStack = (_eMSP - 8);
	uint32_t _eTaskAStack = (_sTaskAStack - TaskA_StackSize);

	// TaskB
	uint32_t _sTaskBStack = (_eTaskAStack - 8);
	uint32_t _eTaskBStack = (_sTaskBStack - TaskB_StackSize);

	while (1)
	{
		if (TaskAFlag == 1)
		{
			TaskAFlag = 0;

			// Switch Context (Write TaskA stack -return- address to PSP, Switch SP to PSP, Switch to UnPrivileged, Call TaskA)
			Set_PSP_Address(_sTaskAStack);
			Switch_To_PSP;
			Switch_To_UnPrivileged;
			TaskA(1, 2, 3, 4);

			// Switch Restore (Switch to Privileged, Switch SP to MSP)
			__asm volatile ("SVC #0x00");	//--> SVC_Handler [handler mode:  Switch to Privileged inside SVC_Handler()]
			Switch_To_MSP;
		}
		else if (TaskBFlag == 1)
		{
			TaskBFlag = 0;

			// Switch Context (Write TaskB stack -return- address to PSP, Switch SP to PSP, Switch to UnPrivileged, Call TaskB)
			Set_PSP_Address(_sTaskBStack);
			Switch_To_PSP;
			Switch_To_UnPrivileged;
			TaskB(1, 2, 3, 4, 5);

			// Switch Restore (Switch to Privileged, Switch SP to MSP)
			__asm volatile ("SVC #0x00");	//--> SVC_Handler [handler mode:  Switch to Privileged inside SVC_Handler()]
			Switch_To_MSP;
		}
	}
}


void clock_init()
{
	RCC_GPIOA_CLK_EN(); //Enable PORTA Clock
	RCC_GPIOB_CLK_EN(); //Enable PORTB Clock
	RCC_AFIO_CLK_EN();	//Enable AFIO Clock
}
void GPIO_init()
{
	EXTI_Config_t myextiConfig;
	GPIO_PinConfig_t mypinConfig;

	//PB.9 EXTI.
	myextiConfig.EXTI_Pin = PB9_EXTI9;
	myextiConfig.EXTI_Trigger = EXTI_Trigger_RISING;
	myextiConfig.EXTI_EN_OR_DIS = EXTI_ENABLED;
	myextiConfig.ptr_CallbackFUN = &myPB9EXTIHandler;
	MCAL_EXTI_Init(&myextiConfig);

	//PA.13 General purpose output push-pull, max speed 2 MHz.
	mypinConfig.GPIO_PinNumber = GPIO_PinNumber_13;
	mypinConfig.GPIO_PinMode = GPIO_PinMode_Output_PUSHPULL;
	mypinConfig.GPIO_PinSpeed = GPIO_PinSpeed_2MHz;
	MCAL_GPIO_InitPin(GPIOA, &mypinConfig);

	//PA.14 General purpose output push-pull, max speed 2 MHz.
	mypinConfig.GPIO_PinNumber = GPIO_PinNumber_14;
	mypinConfig.GPIO_PinMode = GPIO_PinMode_Output_PUSHPULL;
	mypinConfig.GPIO_PinSpeed = GPIO_PinSpeed_2MHz;
	MCAL_GPIO_InitPin(GPIOA, &mypinConfig);
}
int main(void)
{
	int32_t Result = 0;
	clock_init();
	GPIO_init();

	Result = OS_SVC_Service(4, 2, 1);
	Result = OS_SVC_Service(4, 2, 2);
	Result = OS_SVC_Service(4, 2, 3);

	__asm volatile ("SVC #0x04");	//SVC service to raise PendSV

	mainOS();

	while(1)
	{
	}
}
