/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "Clock_Registers.h"
#include "GPIOx_Registers.h"
#include "EXTI_Registers.h"
#include "AFIO_Registers.h"


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void clock_init()
{
	volatile RCC_APB2ENR_t* const RCC_APB2ENR = (RCC_APB2ENR_t*)(RCC_BASE+0x18);

	RCC_APB2ENR->IOPAEN = 0b1; //Enable PORTA Clock
	RCC_APB2ENR->AFIOEN = 0b1; //Enable AFIO Clock
}
void GPIOA_init()
{
	volatile GPIOx_CRL_t* const GPIOA_CRL = (GPIOx_CRL_t*)(PORTA_BASE+0x00);
	volatile GPIOx_CRH_t* const GPIOA_CRH = (GPIOx_CRH_t*)(PORTA_BASE+0x04);

	//Port x mode bits
	GPIOA_CRL->MODE0 = 0b00; // 00: Input mode (reset state)
	GPIOA_CRH->MODE13 = 0b10; // 10: Output mode, max speed 2 MHz.

	//Port x configuration bits
	GPIOA_CRL->CNF0 = 0b01; // 01: Floating input (reset state)
	GPIOA_CRH->CNF13 = 0b00; // 00: General purpose output push-pull
}
void AFIO_init()
{
	volatile AFIO_EXTICR1_t* const AFIO_EXTICR1 = (AFIO_EXTICR1_t*)(AFIO_BASE+0x08);

	// EXTI x configuration
	AFIO_EXTICR1->EXTI0 = 0b0000; // 0000: PA[x] pin
}
void EXTI_init()
{
	volatile EXTI_IMR_t* const EXTI_IMR = (EXTI_IMR_t*)(EXTI_BASE+0x00);
	volatile EXTI_FTSR_t* const EXTI_FTSR = (EXTI_FTSR_t*)(EXTI_BASE+0x08);


	//Configure the mask bits
	EXTI_IMR->MR0 = 0b1;

	//Configure the Trigger Selection bits
	EXTI_FTSR->TR0 = 0b1;
}
void NVIC_init()
{
	volatile uint32_t* const SETENA = (uint32_t*)(0xE000E100);

	//Setting a bit in the Interrupt Set-Enable Register enables the corresponding interrupt.
	*SETENA |= (1<<6); //Enable EXTI0 interrupt (Position 6 on Vector table)
}

void EXTI0_IRQHandler()
{
	volatile GPIOx_ODR_t* const GPIOA_ODR = (GPIOx_ODR_t*)(PORTA_BASE+0x0C);
	volatile EXTI_PR_t* const EXTI_PR = (EXTI_PR_t*)(EXTI_BASE+0x14);

	GPIOA_ODR->ODR13 ^= 0b1; //Toggle GPIOA.13

	//Clear pending request to avoid infinite interrupt
	EXTI_PR->PR0 = 0b1; // bit is cleared by writing a ‘1’ into the bit.
}

int main(void)
{
	clock_init();
	GPIOA_init();
	AFIO_init();
	EXTI_init();
	NVIC_init();

	while(1);
}
