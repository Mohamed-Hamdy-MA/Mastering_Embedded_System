/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#pragma pack(1)
typedef struct {
	uint32_t HSION:1;
	uint32_t HSIRDY:1;
	uint32_t :1;
	uint32_t HSITRIM:5;
	uint32_t HSICAL:8;
	uint32_t HSEON:1;
	uint32_t HSERDY:1;
	uint32_t HSEBYP:1;
	uint32_t CSSON:1;
	uint32_t :4;
	uint32_t PLLON:1;
	uint32_t PLLRDY:1;
	uint32_t :6;
}SRCC_CR_t;

#pragma pack(1)
typedef struct {
	uint32_t SW:2;
	uint32_t SWS:2;
	uint32_t HPRE:4;
	uint32_t PPRE1:3;
	uint32_t PPRE2:3;
	uint32_t ADC:2;
	uint32_t PLLSRC:1;
	uint32_t PLLXTPRE:1;
	uint32_t PLLMUL:4;
	uint32_t USBPRE:1;
	uint32_t :1;
	uint32_t MCO:3;
	uint32_t :5;
}SRCC_CFGR_t;

#pragma pack(1)
typedef struct {
	uint32_t :2;
	uint32_t IOPAEN:1;
	uint32_t :29;
}SRCC_APB2ENR_t;

#define RCC_BASE		0x40021000
#define PORTA_BASE		0x40010800

#define GPIOA_CRH		*(volatile uint32_t*)(PORTA_BASE+0x04)
#define GPIOA_ODR		*(volatile uint32_t*)(PORTA_BASE+0x0C)
/*
void clock_init(){
	volatile SRCC_CR_t* const RCC_CR = (SRCC_CR_t*)(RCC_BASE+0x00);
	volatile SRCC_CFGR_t* const RCC_CFGR = (SRCC_CFGR_t*)(RCC_BASE+0x04);
	volatile SRCC_APB2ENR_t* const RCC_APB2ENR = (SRCC_APB2ENR_t*)(RCC_BASE+0x18);

	//	APB1 Bus frequency 4MHZ
	//	APB2 Bus frequency 2MHZ
	//	AHB frequency 8 MHZ
	//	SysClk 8 MHZ
	//	Use only internal HSI_RC

	RCC_CFGR->PPRE1 = 0b100; //100: HCLK divided by 2
	RCC_CFGR->PPRE2 = 0b101; //101: HCLK divided by 4
	RCC_APB2ENR->IOPAEN = 0b1; //Enable PORTA Clock
}
*/
/*
void clock_init(){
	volatile SRCC_CR_t* const RCC_CR = (SRCC_CR_t*)(RCC_BASE+0x00);
	volatile SRCC_CFGR_t* const RCC_CFGR = (SRCC_CFGR_t*)(RCC_BASE+0x04);
	volatile SRCC_APB2ENR_t* const RCC_APB2ENR = (SRCC_APB2ENR_t*)(RCC_BASE+0x18);

	//	APB1 Bus frequency 16MHZ
	//	APB2 Bus frequency 8MHZ
	//	AHB frequency 32 MHZ
	//	SysClk 32 MHZ
	//	Use only internal HSI_RC

	// PLLSRC & PLLMUL bits can be written only when PLL is disabled.
	RCC_CFGR->PLLSRC = 0b0; //0: HSI oscillator clock / 2 selected as PLL input clock
	RCC_CFGR->PLLMUL = 0b0110; //0110: PLL input clock x 8

	RCC_CR->PLLON = 0b1; //1: PLL ON

	while(!RCC_CR->PLLRDY){
	}

	RCC_CFGR->PPRE1 = 0b100; //100: HCLK divided by 2
	RCC_CFGR->PPRE2 = 0b101; //101: HCLK divided by 4

	RCC_CFGR->SW = 0b10; //10: PLL selected as system clock

	RCC_APB2ENR->IOPAEN = 0b1; //Enable PORTA Clock
}
*/

void clock_init(){
	volatile SRCC_CR_t* const RCC_CR = (SRCC_CR_t*)(RCC_BASE+0x00);
	volatile SRCC_CFGR_t* const RCC_CFGR = (SRCC_CFGR_t*)(RCC_BASE+0x04);
	volatile SRCC_APB2ENR_t* const RCC_APB2ENR = (SRCC_APB2ENR_t*)(RCC_BASE+0x18);

	//	APB1 Bus frequency 16MHZ
	//	APB2 Bus frequency 16MHZ
	//	AHB frequency 32 MHZ
	//	SysClk 32 MHZ
	//	Use only internal HSI_RC

	// PLLSRC & PLLMUL bits can be written only when PLL is disabled.
	RCC_CFGR->PLLSRC = 0b0; //0: HSI oscillator clock / 2 selected as PLL input clock
	RCC_CFGR->PLLMUL = 0b0110; //0110: PLL input clock x 8

	RCC_CR->PLLON = 0b1; //1: PLL ON

	while(!RCC_CR->PLLRDY){
	}

	RCC_CFGR->PPRE1 = 0b100; //100: HCLK divided by 2
	RCC_CFGR->PPRE2 = 0b100; //100: HCLK divided by 4

	RCC_CFGR->SW = 0b10; //10: PLL selected as system clock

	RCC_APB2ENR->IOPAEN = 0b1; //Enable PORTA Clock
}


int main(void)
{

	clock_init();

	int i;
	GPIOA_CRH &=0xFF0FFFFF;
	GPIOA_CRH |=0x00200000;
	while (1)
	{
		GPIOA_ODR |=1<<13;
		for (i=0; i<5000; i++);
		GPIOA_ODR &=~(1<<13);
		for (i=0; i<5000; i++);
	}
	return 0;
}
